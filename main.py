from typing import List, Dict, Any
from functools import reduce
from collections import defaultdict
from datetime import datetime

import dateutil.parser

# import sqlite3
# connection = sqlite3.connect(':memory:')


class Table:
    def __init__(self, header, rows):
        self.header = header
        self.rows = rows


def _load_csv(filepath) -> List[Dict[str, Any]]:
    import csv
    with open(filepath, "r") as csvfile:
        reader = csv.reader(csvfile, delimiter=',')
        header = next(reader)
        return list(dict(zip(header, row)) for row in reader)


def _load_price_csv(filepath):
    """Returns a dict mapping from date to price"""
    import csv
    with open(filepath, "r") as csvfile:
        price_by_date = {}
        reader = csv.reader(csvfile, delimiter=',')
        next(reader)  # discard header
        for row in reader:
            price_by_date[row[0]] = float(row[1])
        return price_by_date


def _format_csv_from_kraken(trades_csv):
    "Format a CSV from a particular source into a canonical data format"
    for trade in trades_csv:
        # Kraken has really weird pair formatting...
        pairlen = int(len(trade["pair"]) / 2)
        trade["pair"] = (trade["pair"][:pairlen], trade["pair"][pairlen:])
        trade["pair"] = tuple(map(lambda asset: "XXBTC" if asset == "XBT" else asset, trade["pair"]))

        trade["time"] = dateutil.parser.parse(trade["time"])
        trade["price"] = float(trade["price"])
        trade["vol"] = float(trade["vol"])
        trade["cost"] = float(trade["cost"])
    return trades_csv


def _print_trades(trades, n=None):
    h = dict(zip(trades[0].keys(), trades[0].keys()))
    print(f"{h['time']:10}  {h['pair']:12.12}  {h['type']:4.4}  {h['price']:12}  {h['vol']:9}  {h['cost']:12.10}  {h['costbasis_usd']:14.14}")
    for d in (trades[:n] if n else trades):
        print(f"{d['time'].isoformat():.10}  {' / '.join(d['pair']):12}  {d['type']:4.4}  {d['price']:12.6}  {d['vol']:9.6}  {d['cost']:12.6}  {str(d['costbasis_usd']):14.14}")


def _sum_trades(t1, t2):
    # Price becomes volume-weighted average
    t1["price"] = (t1["price"] * t1["vol"] + t2["price"] * t2["vol"]) / (t1["vol"] + t2["vol"])
    # Volume becomes sum of trades
    t1["vol"] += t2["vol"]
    t1["cost"] += t2["cost"]
    return t1


def test_sum_trades():
    t1 = {"price": 1, "vol": 1, "cost": 1}
    t2 = {"price": 2, "vol": 1, "cost": 2}
    t3 = _sum_trades(t1, t2)
    assert t3["price"] == 1.5
    assert t3["vol"] == 2
    assert t3["cost"] == 3


def _reduce_trades(trades):
    """Merges consequtive trades in the same pair on the same day"""
    def r(processed, next):
        if len(processed) == 0:
            processed.append(next)
        else:
            last = processed[-1]
            if last["time"].date() == next["time"].date() and \
               last["pair"] == next["pair"]:
                processed[-1] = _sum_trades(last, next)
            else:
                processed.append(next)
        return processed
    return reduce(r, trades, [])


def _calc_cost_basis(trades):
    # TODO: This is probably not right, but it's a start.

    # TODO: The price CSV should be autogenerated from something like:
    #       https://coinmarketcap.com/currencies/bitcoin/historical-data/
    btcusd_price_csv = _load_price_csv("data_public/prices-XBT.csv")

    # TODO: Use actual rates
    eurusd_rate = 1.23

    for trade in trades:
        if trade["pair"][1] == "ZEUR":
            # How are the sell cases to be handled?
            if trade["type"] == "buy":
                # Example: Buy ETH with EUR
                trade["costbasis_usd"] = trade["cost"] * eurusd_rate
            else:
                trade["costbasis_usd"] = 0
        elif trade["pair"][1] in ["XXBT", "XBT"] and trade["type"] == "buy":
            # Example: Buy ETH with BTC
            date = trade["time"].date().isoformat()
            btcusd_rate = btcusd_price_csv[date]
            trade["costbasis_usd"] = trade["cost"] * btcusd_rate
        else:
            print(f"Could not calculate cost basis for pair: {trade['pair']}")
            trade["costbasis_usd"] = None

        # print(f"{trade['costbasis_usd']} {trade['fee']}")

    return trades


def _cost_basis_per_asset(trades):
    costbasis = defaultdict(lambda: 0)
    vol = defaultdict(lambda: 0)
    for trade in trades:
        if trade["costbasis_usd"]:
            costbasis[trade["pair"][0]] += trade["costbasis_usd"]
            vol[trade["pair"][0]] += trade["vol"]

    print(f"Asset   Costbasis         Vol     Cost/vol")
    for asset in costbasis:
        print(f"{asset}  {costbasis[asset]:10.10}  {vol[asset]:10.10}  {costbasis[asset]/vol[asset]:10.10}")


def _filter_trades_by_time(trades, year):
    return list(filter(lambda t: datetime(year, 1, 1) <= t["time"] < datetime(year + 1, 1, 1), trades))


_t1 = {"time": datetime(2017, 12, 30, 23, 42)}
_t2 = {"time": datetime(2018, 1, 1, 1, 42)}
assert 1 == len(_filter_trades_by_time([_t1, _t2], 2017))
assert 1 == len(_filter_trades_by_time([_t1, _t2], 2018))


def _calculate_inout_balances(balances, trades):
    for t in trades:
        if t["type"] == "buy":   # Buy asset1 in pair using asset2
            balances[t["pair"][0]] += t["vol"]
            balances[t["pair"][1]] -= t["cost"]
        elif t["type"] == "sell":
            balances[t["pair"][0]] -= t["vol"]
            balances[t["pair"][1]] += t["cost"]

    return balances


if __name__ == "__main__":
    trades_csv = _load_csv("data_private/kraken-trades.csv")
    trades = _format_csv_from_kraken(trades_csv)
    # print(trades[0].keys())
    trades = _reduce_trades(trades)
    trades = _calc_cost_basis(trades)
    _print_trades(trades)

    print("\n# Cost basis per asset")
    _cost_basis_per_asset(trades)

    for year in range(2017, 2019):
        balances = defaultdict(lambda: 0)  # type: Dict[str, int]
        trades_for_year = _filter_trades_by_time(trades, year)
        _calculate_inout_balances(balances, trades_for_year)
        print(f"\n# Balance diff for {year}")
        for k, v in balances.items():
            print(f"{k:6.6} {v}")
